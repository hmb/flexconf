***************************************************************************
flexconf - flexible configuration generator
Copyright (c) 2008-2009 Holger Böhnke

This file is part of flexconf.

Flexconf is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
***************************************************************************



********** [GL] PROLOG
/*-------------------------------------------------------------------
  This file is part of the structure de/serializer flexconf.
  It has been automatically created by:

  $(packagename)

  !!! DO NOT MODIFY MANUALLY !!!

  Bugreports to $(bugreport)
  -------------------------------------------------------------------
  flexconf - flexible configuration generator
  Copyright (c) 2008-2009 Holger Böhnke

  This file is part of flexconf.

  Flexconf is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  -------------------------------------------------------------------
  As a special exception, you may create a larger work that contains
  part or all of the de/serializer functions and distribute that work
  under terms of your choice, as long as that work itself does not
  provide a functionality similar to flexconf.
  Alternatively, if you modify or redistribute this file itself,
  you may (at your option) remove this special exception, which will
  cause the file to be licensed under the GNU General Public
  License without this special exception.
*/

********** [END]






********** [CH] PROLOG
// ------------------------------------------------------------------
// This is the structure common header file.
// ------------------------------------------------------------------

#ifndef _$(basename)Com_h_
#define _$(basename)Com_h_

#ifdef _MSC_VER
#define _CRT_SECURE_NO_DEPRECATE
#endif

#include <string>
#include <list>
#include <set>
#include <map>

struct SLongHex
{
  SLongHex() { }
  SLongHex(unsigned long ulHex) : mulHex(ulHex) { }

  unsigned long mulHex;

  bool operator == (const SLongHex & cmp) const { return mulHex == cmp.mulHex; }
  bool operator >= (const SLongHex & cmp) const { return mulHex >= cmp.mulHex; }
  bool operator <= (const SLongHex & cmp) const { return mulHex <= cmp.mulHex; }
  bool operator >  (const SLongHex & cmp) const { return mulHex >  cmp.mulHex; }
  bool operator <  (const SLongHex & cmp) const { return mulHex <  cmp.mulHex; }
  bool operator != (const SLongHex & cmp) const { return mulHex != cmp.mulHex; }

  unsigned long operator = (unsigned long ulHex) { return mulHex=ulHex; }
  operator unsigned long () const { return mulHex; }
};

********** [END]


********** [CH] FILE PROLOG
#include "$(headerfile)"
********** [END]


********** [CH] STRUCT PROLOG
********** [END]


********** [CH] GENERIC DECL
********** [END]


********** [CH] VECTOR DECL
********** [END]


********** [CH] SET/LIST DECL
********** [END]


********** [CH] MAP DECL
********** [END]


********** [CH] STRUCT EPILOG
********** [END]


********** [CH] FILE EPILOG
********** [END]


********** [CH] EPILOG
#endif // _$(basename)Com_h_
********** [END]






********** [CI] PROLOG
// ------------------------------------------------------------------
// This is the structure common implementation file.
// ------------------------------------------------------------------

#include "$(basename)Com.h"
********** [END]


********** [CI] FILE PROLOG
********** [END]


********** [CI] STRUCT PROLOG
********** [END]


********** [CI] GENERIC DECL
********** [END]


********** [CI] VECTOR DECL
********** [END]


********** [CI] SET/LIST DECL
********** [END]


********** [CI] MAP DECL
********** [END]


********** [CI] STRUCT EPILOG
********** [END]


********** [CI] FILE EPILOG
********** [END]


********** [CI] EPILOG
********** [END]






********** [SH] PROLOG
// ------------------------------------------------------------------
// This is the structure serializer header file.
// ------------------------------------------------------------------

#ifndef _$(basename)Ser_h_
#define _$(basename)Ser_h_

#include <stdio.h>

#ifdef _MSC_VER
#define snprintf _snprintf
#pragma warning(disable: 4786)
#endif


// ------------------------------------------------------------------
// Generic baseclass for writing a json snippet.
// This class must be implemented to write to a specific type of
// output, like file, std:string, buffer etc.
// ------------------------------------------------------------------

class CWriter
{
public:
  static const int NUL_TERM_STRING  = -1;

public:
  CWriter();
  virtual ~CWriter();

  void StartObject(const char * pszTag);
  void EndObject(const char * pszTag);
  void StartArray(const char * pszTag);
  void EndArray(const char * pszTag);
  void StartElement(const char * pszName);
  void EndElement(const char * pszName);

  void Write(const std::string & data);
  void Write(const char * data, int dataLen = NUL_TERM_STRING);

  void PutData(const char * data, int dataLen);

private:
  virtual void startObjectImpl(const char * pszTag)             = 0;
  virtual void endObjectImpl(const char * pszTag)               = 0;
  virtual void startArrayImpl(const char * pszTag)              = 0;
  virtual void endArrayImpl(const char * pszTag)                = 0;
  virtual void startElementImpl(const char * pszName)           = 0;
  virtual void endElementImpl(const char * pszName)             = 0;

  virtual void writeImpl(const std::string & data)              = 0;
  virtual void writeImpl(const char * data, int dataLen)        = 0;

  virtual void putDataImpl(const char * data, int dataLen)      = 0;
};


class CWriterJson : public CWriter
{
public:
  CWriterJson();
  ~CWriterJson();

  void SetCondensed();
  void SetPretty();

  bool GetNewline() const;
  void SetNewline(bool newline);

  int GetIndentation() const;
  void SetIndentation(int indentation);

  int GetAlignmentObj() const;
  void SetAlignmentObj(int alignmentObj);

  int GetAlignmentElem() const;
  void SetAlignmentElem(int alignmentElem);

  bool IsColonWhitespace() const;
  void SetColonWhitespace(bool colonWhitespace);

private:
  void startObjectImpl(const char * pszTag);
  void endObjectImpl(const char * pszTag);
  void startArrayImpl(const char * pszTag);
  void endArrayImpl(const char * pszTag);
  void startElementImpl(const char * pszName);
  void endElementImpl(const char * pszName);

  void writeImpl(const std::string & data);
  void writeImpl(const char * data, int dataLen = NUL_TERM_STRING);

  void putDataImpl(const char * data, int dataLen);

private:
  virtual void put(const std::string & data)            = 0;
  virtual void put(const char * data, int dataLen)      = 0;
  virtual void put(char data, int count = 1)            = 0;

private:
  void startCompound(const char * name, char bracket);
  void endCompound(const char * name, char bracket);
  void elemName(const char * name, int alignment);

  void indent();
  void newline();

  int           mDepth;
  bool          mNewStruct;
  bool          mLf;

  bool          mNewline;
  int           mIndentation;
  int           mAlignmentObj;
  int           mAlignmentElem;
  bool          mColonWhitespace;

  static const bool DEFAULT_NEWLINE           = true;
  static const int  DEFAULT_IDENT             = 2;
  static const int  DEFAULT_ALIGNMENTOBJ      = 1;
  static const int  DEFAULT_ALIGNMENTELEM     = 1;
  static const bool DEFAULT_COLONWHITESPACE   = true;
};


class CWriterJsonString : public CWriterJson
{
public:
  CWriterJsonString(std::string & outBuffer);
  virtual ~CWriterJsonString();

private:
  virtual void put(const std::string & data);
  virtual void put(const char * data, int dataLen);
  virtual void put(char data, int count);

private:
  std::string & mOutBuffer;
};


********** [END]


********** [SH] FILE PROLOG
********** [END]


********** [SH] STRUCT PROLOG

void serialize(CWriter & writer, const $(name) & rObject, const char * pszTag = 0,
  const char * pszIdTag = 0, const std::string * pstrIdValue = 0);
********** [END]


********** [SH] GENERIC DECL
********** [END]


********** [SH] VECTOR DECL
********** [END]


********** [SH] SET/LIST DECL
********** [END]


********** [SH] MAP DECL
********** [END]


********** [SH] STRUCT EPILOG
********** [END]


********** [SH] FILE EPILOG
********** [END]


********** [SH] EPILOG



void serialize(char * pBuffer, int nBufSize, const bool & rObject);

void serialize(char * pBuffer, int nBufSize, const short & rObject);

void serialize(char * pBuffer, int nBufSize, const unsigned short & rObject);

void serialize(char * pBuffer, int nBufSize, const int & rObject);

void serialize(char * pBuffer, int nBufSize, const unsigned int & rObject);

void serialize(char * pBuffer, int nBufSize, const long & rObject);

void serialize(char * pBuffer, int nBufSize, const unsigned long & rObject);

void serialize(char * pBuffer, int nBufSize, const float & rObject);

void serialize(char * pBuffer, int nBufSize, const double & rObject);

void serialize(char * pBuffer, int nBufSize, const SLongHex & rObject);



// serialize a std::string object
void serialize(CWriter & writer, const std::string & rObject, const char * pszTag);



// serialize any of the objects for that an above function is defined
template <class _T>
void serialize(CWriter & writer, const _T & rObject, const char * pszTag)
{
  writer.StartElement(pszTag);

  // enough for int and double types
  const int BUFSIZE = 80;

  char szBuffer[BUFSIZE];
  serialize(szBuffer, BUFSIZE, rObject);
  writer.PutData(szBuffer, CWriter::NUL_TERM_STRING);

  writer.EndElement(pszTag);
}



// serialize any set object for witch a key serialize function exists
template <class _K>
void serialize(
  CWriter & writer, const std::set<_K> & rObject,
  const char * pszTag, const char * pszTagItem)
{
  writer.StartArray(pszTag);
  for (typename std::set<_K>::const_iterator itr=rObject.begin(); itr!=rObject.end(); ++itr)
  {
    // serialize the key object
    serialize(writer, *itr, 0);
  }
  writer.EndArray(pszTag);
}



// serialize any list object for witch a serialize function exists
template <class _T>
void serialize(
  CWriter & writer, const std::list<_T> & rObject,
  const char * pszTag, const char * pszTagItem)
{
  writer.StartArray(pszTag);
  for (typename std::list<_T>::const_iterator itr=rObject.begin(); itr!=rObject.end(); ++itr)
  {
    // serialize the key object
    serialize(writer, *itr, 0);
  }
  writer.EndArray(pszTag);
}



// serialize a std::map<std::string, _T> object
// this special case can be serialized as object with the key beeing the json
// id string
template <class _T>
void serialize(
  CWriter & writer, const std::map<std::string, _T> & rObject,
  const char * pszTag, const char * pszTagItem, const char * pszTagId)
{
  writer.StartObject(pszTag);
  for (typename std::map<std::string, _T>::const_iterator itr=rObject.begin(); itr!=rObject.end(); ++itr)
  {
    serialize(writer, itr->second, itr->first.c_str());
  }
  writer.EndObject(pszTag);
}



// serialize any other map object for witch a key serialize function exists
// this is serialized as array with the key beeing written inside the structure
// as the key is possibly not valid as json object id
template <class _K, class _T>
void serialize(
  CWriter & writer, const std::map<_K, _T> & rObject,
  const char * pszTag, const char * pszTagItem, const char * pszTagId)
{
  writer.StartArray(pszTag);
  for (typename std::map<_K, _T>::const_iterator itr=rObject.begin(); itr!=rObject.end(); ++itr)
  {
    // first serialize the key to a string
    const int BUFSIZE = 1024;
    char szBuffer[BUFSIZE];
    serialize(szBuffer, BUFSIZE, itr->first);
    std::string strBuffer(szBuffer);
    // serialize the object with a string key
    serialize(writer, itr->second, 0, pszTagId, &strBuffer);
  }
  writer.EndArray(pszTag);
}



// serialize a std::multimap<std::string, _T> object
template <class _T>
void serialize(
  CWriter & writer, const std::multimap<std::string, _T> & rObject,
  const char * pszTag, const char * pszTagItem, const char * pszTagId)
{
  writer.StartArray(pszTag);
  for (typename std::multimap<std::string, _T>::const_iterator itr=rObject.begin(); itr!=rObject.end(); ++itr)
  {
    serialize(writer, itr->second, 0, pszTagId, &itr->first);
  }
  writer.EndArray(pszTag);
}



// serialize any other multimap object for witch a key serialize function exists
template <class _K, class _T>
void serialize(
  CWriter & writer, const std::multimap<_K, _T> & rObject,
  const char * pszTag, const char * pszTagItem, const char * pszTagId)
{
  writer.StartArray(pszTag);
  for (typename std::multimap<_K, _T>::const_iterator itr=rObject.begin(); itr!=rObject.end(); ++itr)
  {
    // first serialize the key to a string
    const int BUFSIZE = 1024;
    char szBuffer[BUFSIZE];
    serialize(szBuffer, BUFSIZE, itr->first);
    std::string strBuffer(szBuffer);
    // serialize the object with a string key
    serialize(writer, itr->second, 0, pszTagId, &strBuffer);
  }
  writer.EndArray(pszTag);
}


#endif // _$(basename)Ser_h_
********** [END]






********** [SI] PROLOG
// ------------------------------------------------------------------
// This is the structure serializer implementation file.
// ------------------------------------------------------------------

#include "$(basename)Com.h"
#include "$(basename)Ser.h"
#include <string.h>



CWriter::CWriter()
{
}

CWriter::~CWriter()
{
}

void CWriter::StartObject(const char * pszTag)
{
  startObjectImpl(pszTag);
}

void CWriter::EndObject(const char * pszTag)
{
  endObjectImpl(pszTag);
}

void CWriter::StartArray(const char * pszTag)
{
  startArrayImpl(pszTag);
}

void CWriter::EndArray(const char * pszTag)
{
  endArrayImpl(pszTag);
}

void CWriter::StartElement(const char * pszName)
{
  startElementImpl(pszName);
}

void CWriter::EndElement(const char * pszName)
{
  endElementImpl(pszName);
}

void CWriter::Write(const std::string & data)
{
  writeImpl(data);
}

void CWriter::Write(const char * data, int dataLen)
{
  writeImpl(data, dataLen);
}

void CWriter::PutData(const char * data, int dataLen)
{
  putDataImpl(data, dataLen);
}



CWriterJson::CWriterJson()
  :
  mDepth(0),
  mNewStruct(true),
  mLf(false),
  mNewline(DEFAULT_NEWLINE),
  mIndentation(DEFAULT_IDENT),
  mAlignmentObj(DEFAULT_ALIGNMENTOBJ),
  mAlignmentElem(DEFAULT_ALIGNMENTELEM),
  mColonWhitespace(DEFAULT_COLONWHITESPACE)
{
}

CWriterJson::~CWriterJson()
{
}


void CWriterJson::SetCondensed()
{
  SetNewline(false);
  SetIndentation(0);
  SetAlignmentObj(0);
  SetAlignmentElem(0);
  SetColonWhitespace(false);
}

void CWriterJson::SetPretty()
{
  SetNewline(DEFAULT_NEWLINE);
  SetIndentation(DEFAULT_IDENT);
  SetAlignmentObj(DEFAULT_ALIGNMENTOBJ);
  SetAlignmentElem(DEFAULT_ALIGNMENTELEM);
  SetColonWhitespace(DEFAULT_COLONWHITESPACE);
}

bool CWriterJson::GetNewline() const
{
  return mNewline;
}

void CWriterJson::SetNewline(bool newline)
{
  mNewline = newline;
}

int CWriterJson::GetIndentation() const
{
  return mIndentation;
}

void CWriterJson::SetIndentation(int indentation)
{
  mIndentation = indentation;
}

int CWriterJson::GetAlignmentObj() const
{
  return mAlignmentObj;
}

void CWriterJson::SetAlignmentObj(int alignmentObj)
{
  mAlignmentObj = alignmentObj;
}

int CWriterJson::GetAlignmentElem() const
{
  return mAlignmentElem;
}

void CWriterJson::SetAlignmentElem(int alignmentElem)
{
  mAlignmentElem = alignmentElem;
}

bool CWriterJson::IsColonWhitespace() const
{
  return mColonWhitespace;
}

void CWriterJson::SetColonWhitespace(bool colonWhitespace)
{
  mColonWhitespace = colonWhitespace;
}


void CWriterJson::startObjectImpl(const char * pszTag)
{
  startCompound(pszTag, '{');
}

void CWriterJson::endObjectImpl(const char * pszTag)
{
  endCompound(pszTag, '}');
}

void CWriterJson::startArrayImpl(const char * pszTag)
{
  startCompound(pszTag, '[');
}

void CWriterJson::endArrayImpl(const char * pszTag)
{
  endCompound(pszTag, ']');
}

void CWriterJson::startElementImpl(const char * pszName)
{
  if (!mNewStruct)
  {
    put(',');
    newline();
  }
  else
  {
    mNewStruct = false;
  }

  indent();
  elemName(pszName, mAlignmentElem);
}

void CWriterJson::endElementImpl(const char * pszName)
{
}


void CWriterJson::writeImpl(const std::string & data)
{
  writeImpl(data.c_str());
}

void CWriterJson::writeImpl(const char * data, int dataLen)
{
  put('"');

  const char  * pos       = data;   // current start position
  const char  * end       = pos;    // current end position

  // one position after the last, if dataLen is given, 0 otherwise
  const char * const fin  = (dataLen == NUL_TERM_STRING) ? 0 : data + dataLen;

  const char  * special   = 0;      // replacement for an escapes special char
  int           count     = 0;      // number of unescaped chars after pos

  const int SPBUFLEN  = 7;    // buffer for numerical escapes: \u0000 == 7 chars
  char spbuffer[SPBUFLEN] = { '\\', 'u', '0', '0', '0', '0', 0 };

  // either we found a nullchar or dataLen is reached
  while (*end && end!=fin)
  {
    switch (*end)
    {
    case '"':
      special  = "\\\"";
      break;

    case '\\':
      special  = "\\\\";
      break;

// TODO needs not to be escaped
//      possibly make it optional
//    case '/':
//      special  = "\\/";
//      break;

    case '\b':
      special  = "\\b";
      break;

    case '\f':
      special  = "\\f";
      break;

    case '\n':
      special  = "\\n";
      break;

    case '\r':
      special  = "\\r";
      break;

    case '\t':
      special  = "\\t";
      break;

    default:
      if ( (*end & '\xE0') || (*end == '\x7F') )
      {
        // normal character
        ++end;
        ++count;
      }
      else
      {
        // control char
        char c = (*end & '\xF0' ) >> 4;
        spbuffer[4] = c + (c>9? 'a'-10 : '0');

        c = (*end & '\x0F' );
        spbuffer[5] = c + (c>9? 'a'-10 : '0');

        special = spbuffer;
      }
      break;
    }

    // character at end position is a specialchar
    if (special)
    {
      // first write accumulated non-special chars
      if (count>0)
      {
        put(pos, count);
      }

      // then write the specialchar found
      put(special);

      // now restart scanning at next position
      pos     = end + 1;
      end     = pos;
      special = 0;
      count   = 0;
    }
  }

  // write remaining string, not written in the loop
  if (count>0)
  {
    put(pos, count);
  }

  put('"');
}


void CWriterJson::putDataImpl(const char * data, int dataLen)
{
  if (dataLen == NUL_TERM_STRING)
  {
    put(data);
  }
  else
  {
    put(data, dataLen);
  }
}


void CWriterJson::startCompound(const char * name, char bracket)
{
  if (!mNewStruct)
  {
    put(',');
    newline();
  }
  else
  {
    mNewStruct = false;
  }

  indent();
  elemName(name, mAlignmentObj);

  put(bracket);
  newline();
  ++mDepth;
  mNewStruct = true;
}

void CWriterJson::endCompound(const char * name, char bracket)
{
  if (!mNewStruct)
  {
    newline();
  }
  else
  {
    mNewStruct = false;
  }

  --mDepth;
  indent();
  put(bracket);
}

void CWriterJson::elemName(const char * name, int alignment)
{
  if (name)
  {
    writeImpl(name);

    int namelen = strlen(name);
    int align   = alignment <= 0 ? 0 :
                  (alignment >= namelen? alignment - namelen : 1);

    if (align > 0)
    {
      put(' ', align);
    }

    put(':');

    if (mColonWhitespace)
    {
      put(' ');
    }
  }
}

void CWriterJson::indent()
{
  if (mLf)
  {
    put(' ', mDepth * mIndentation);
    mLf = false;
  }
}

void CWriterJson::newline()
{
  if (mNewline)
  {
    put('\n');
  }
  mLf = true;
}



CWriterJsonString::CWriterJsonString(std::string & outBuffer)
  :
  mOutBuffer(outBuffer)
{
}

CWriterJsonString::~CWriterJsonString()
{
}

void CWriterJsonString::put(const std::string & data)
{
  mOutBuffer += data;
}

void CWriterJsonString::put(const char * data, int dataLen)
{
  if (dataLen == NUL_TERM_STRING)
  {
    mOutBuffer += data;
  }
  else
  {
    mOutBuffer.append(data, dataLen);
  }
}

void CWriterJsonString::put(char data, int count)
{
  mOutBuffer.append(count, data);
}

********** [END]


********** [SI] FILE PROLOG
********** [END]


********** [SI] STRUCT PROLOG



void serialize(CWriter & writer, const $(name) & rObject, const char * pszTag,
  const char * pszIdTag, const std::string * pstrIdValue)
{
  writer.StartObject(pszTag);
  if (pszIdTag && pstrIdValue)
  {
    serialize(writer, *pstrIdValue, pszIdTag);
  }
********** [END]


********** [SI] GENERIC DECL
  serialize(writer, rObject.$(name), "$(alias)");
********** [END]


********** [SI] VECTOR DECL
/* TODO
  {for (int n=0; n<$(size); ++n)
  {
    serialize(writer, rObject.$(name)[n], "$(alias)");
  }}
*/
********** [END]


********** [SI] SET/LIST DECL
  serialize(writer, rObject.$(name), "$(alias)", "$(item)");
********** [END]


********** [SI] MAP DECL
  serialize(writer, rObject.$(name), "$(alias)", "$(item)", "$(id)");
********** [END]


********** [SI] STRUCT EPILOG
  /* end of struct serialize function */
  writer.EndObject(pszTag);
}
********** [END]


********** [SI] FILE EPILOG
********** [END]


********** [SI] EPILOG



void serialize(char * pBuffer, int nBufSize, const bool & rObject)
{
  snprintf(pBuffer, nBufSize, rObject? "1" : "0");
}

void serialize(char * pBuffer, int nBufSize, const short & rObject)
{
  snprintf(pBuffer, nBufSize, "%hd", rObject);
}

void serialize(char * pBuffer, int nBufSize, const unsigned short & rObject)
{
  snprintf(pBuffer, nBufSize, "%hu", rObject);
}

void serialize(char * pBuffer, int nBufSize, const int & rObject)
{
  snprintf(pBuffer, nBufSize, "%d", rObject);
}

void serialize(char * pBuffer, int nBufSize, const unsigned int & rObject)
{
  snprintf(pBuffer, nBufSize, "%u", rObject);
}

void serialize(char * pBuffer, int nBufSize, const long & rObject)
{
  snprintf(pBuffer, nBufSize, "%ld", rObject);
}

void serialize(char * pBuffer, int nBufSize, const unsigned long & rObject)
{
  snprintf(pBuffer, nBufSize, "%lu", rObject);
}

void serialize(char * pBuffer, int nBufSize, const float & rObject)
{
  snprintf(pBuffer, nBufSize, "%f", static_cast<double>(rObject));
}

void serialize(char * pBuffer, int nBufSize, const double & rObject)
{
  snprintf(pBuffer, nBufSize, "%f", rObject);
}

void serialize(char * pBuffer, int nBufSize, const SLongHex & rObject)
{
  snprintf(pBuffer, nBufSize, "%lX", rObject.mulHex);
}



void serialize(CWriter & writer, const std::string & rObject, const char * pszTag)
{
  writer.StartElement(pszTag);
  writer.Write(rObject);
  writer.EndElement(pszTag);
}
********** [END]






********** [DH] PROLOG
// ------------------------------------------------------------------
// This is the structure deserializer header file.
// ------------------------------------------------------------------

#ifndef _$(basename)Des_h_
#define _$(basename)Des_h_

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

********** [END]


********** [DH] FILE PROLOG
********** [END]


********** [DH] STRUCT PROLOG
void deserialize(CReader & reader, $(name) & rObject, const char * pszTag =0,
  const char * pszIdTag = 0, std::string * pstrIdValue = 0);
********** [END]


********** [DH] GENERIC DECL
********** [END]


********** [DH] VECTOR DECL
********** [END]


********** [DH] SET/LIST DECL
********** [END]


********** [DH] MAP DECL
********** [END]


********** [DH] STRUCT EPILOG
********** [END]


********** [DH] FILE EPILOG
********** [END]


********** [DH] EPILOG



const char * tkn2str(int token);
void printTkn(int token, const std::string & text);

class CReader
{
public:
  CReader()
  {
  }

  virtual ~CReader()
  {
  }

  enum Token {
    CURLY_BRACKET_LEFT        = '{',
    CURLY_BRACKET_RIGHT       = '}',
    SQUARE_BRACKET_LEFT       = '[',
    SQUARE_BRACKET_RIGHT      = ']',
    COLON                     = ':',
    COMMA                     = ',',
    STRING                    = 0x100,
    NUMBER                    = 0x101,
    END                       = 0xFFFE,
    ERROR                     = 0xFFFF
  };

  int getNibble()
  {
    int c = getChar();

    if (c >= '0' && c <= '9' )
    {
      return c - '0';
    }
    else if (c >= 'A' && c <= 'F' )
    {
      return c + 10 - 'A';
    }
    else if (c >= 'a' && c <= 'f' )
    {
      return c + 10 - 'a';
    }
    else
    {
      return -1;
    }
  }

  int getSpecialChar()
  {
    // read a special char after the initial backslash
    int c = getRawChar();

    switch (c)
    {
    case '"':
      c  = '"';
      break;

    case '\\':
      c = '\\';
      break;

    case '/':
      c = '/';
      break;

    case 'b':
      c  = '\b';
      break;

    case 'f':
      c  = '\f';
      break;

    case 'n':
      c  = '\n';
      break;

    case 'r':
      c  = '\r';
      break;

    case 't':
      c  = '\t';
      break;

    case 'u':
      c =
          getNibble()    << 12
        | getNibble()    << 8
        | getNibble()    << 4
        | getNibble();
      break;
    }

    return c;
  }

  int getString(std::string & text)
  {
    int token = STRING;

    int c = getRawChar();
    for (; c!='"' && c!=END; c = getRawChar())
    {
      switch (c)
      {
      case '\\':
        // read special char
        c = getSpecialChar();
        // no break on purpose
      default:
        text += c;
        break;
      }
    }

    if (c==END)
    {
      // TODO ERROR
      std::cerr << "lexical error: missing terminating double quote" << std::endl;
      token = END;
    }
    return token;
  }

  int getNumber(int c, std::string & text)
  {
    enum State { minus, zero, integral, dot, fraction, e, plusminus, exponent, final };

    State state = minus;
    int token   = ERROR;

    while (state != final)
    {
      switch (state)
      {
        case minus:
          if (c == '-')
          {
            text += c;
            c = getChar();
          }
          state = zero;
          break;

        case zero:
          if (c == '0')
          {
            text += c;
            c = getChar();
            token = NUMBER;
            state = dot;
          }
          else
          {
            state = integral;
          }
          break;

        case integral:
          if (c >= '1' && c <= '9')
          {
            text += c;
            c = getChar();

            while (c >= '0' && c <= '9')
            {
              text += c;
              c = getChar();
            }
            token = NUMBER;
            state = dot;
          }
          else
          {
            // token = ERROR; is still error
            state = final;
          }
          break;

        case dot:
          if (c == '.')
          {
            text += c;
            c = getChar();
            state = fraction;
          }
          else if (c >= '0' && c <= '9')
          {
            token = ERROR;
            state = final;
          }
          else
          {
            state = e;
          }
          break;

        case fraction:
          if (c >= '0' && c <= '9')
          {
            text += c;
            c = getChar();

            while (c >= '0' && c <= '9')
            {
              text += c;
              c = getChar();
            }
            state = e;
          }
          else
          {
            token = ERROR;
            state = final;
          }
          break;

        case e:
          if (c == 'e'  ||  c == 'E')
          {
            text += c;
            c = getChar();
            state = plusminus;
          }
          else
          {
            state = final;
          }
          break;

        case plusminus:
          if (c == '+'  ||  c == '-')
          {
            text += c;
            c = getChar();
          }
          state = exponent;
          break;

        case exponent:
          if (c >= '0' && c <= '9')
          {
            text += c;
            c = getChar();

            while (c >= '0' && c <= '9')
            {
              text += c;
              c = getChar();
            }
            state = final;
          }
          else
          {
            token = ERROR;
            state = final;
          }
          break;

        // shutup compiler about missing enum in switch
        // this code is unreachable anyway
        case final:
          break;
      }
    }

    // putback the last read char that led to final
    putBack(c);

    return token;
  }

  int getToken(std::string & text)
  {
    int token = END;

    text.clear();

    int c = getChar();

    switch (c)
    {
      case CURLY_BRACKET_LEFT:
      case CURLY_BRACKET_RIGHT:
      case SQUARE_BRACKET_LEFT:
      case SQUARE_BRACKET_RIGHT:
      case COLON:
      case COMMA:
        text  = c;
        token = c;
        break;

      case '"':
        token = getString(text);
        break;

      case END:
        // token is already initialized with END
        break;

      default:
        token = getNumber(c, text);
        break;
    }

    printTkn(token, text);

    return token;
  }


private:
  virtual int getChar()       = 0;
  virtual int getRawChar()    = 0;
  virtual void putBack(int c) = 0;
};



class CReaderCharPointer : public CReader
{
public:
  CReaderCharPointer(const char * source) :
    mSource(source)
  {
  }

protected:
  void setSource(const char * source)
  {
    mSource = source;
  }

private:
  void eatWhitespace()
  {
    while ( 0 != *mSource &&
            (
              ' '   == *mSource ||
              '\t'  == *mSource ||
              '\n'  == *mSource ||
              '\r'  == *mSource
            )
          )
    {
      ++mSource;
    }
  }

  int getRawChar()
  {
    int c = *mSource;

    if (c != 0)
    {
      ++mSource;
    }
    else
    {
      c = END;
    }

    return c;
  }

  int getChar()
  {
    eatWhitespace();
    return getRawChar();
  }

  void putBack(int c)
  {
    --mSource;
  }

private:
  const char * mSource;
};



class CReadXmlFile : public CReaderCharPointer
{
public:
  CReadXmlFile() :
    CReaderCharPointer(0)
  {
  }

  bool UseFile(const char * filename)
  {
    setSource(0);
    mstrData.erase();

    FILE * f = fopen(filename, "r");
    if (!f)
    {
      return false;
    }

    while (!feof(f))
    {
      const int BUFSIZE = 4096;
      char szBuffer[BUFSIZE];
      int nRead = fread(szBuffer, 1, BUFSIZE, f);
      mstrData.append(szBuffer, nRead);
    }

    fclose(f);
    setSource(mstrData.c_str());
    return true;
  }

  const std::string & GetData() { return mstrData; }

private:
  std::string mstrData;
};



inline void deserialize(const char * pBuffer, bool & rObject)
{
  rObject =
    0==strncmp(pBuffer, "true", 4) ||
    0==strncmp(pBuffer, "yes", 3) ||
    0==strncmp(pBuffer, "on", 2) ||
    0==strncmp(pBuffer, "1", 1);
}

inline void deserialize(const char * pBuffer, short & rObject)
{
  rObject = static_cast<short>(strtol(pBuffer, 0, 10));
}

inline void deserialize(const char * pBuffer, unsigned short & rObject)
{
  rObject = static_cast<unsigned short>(strtoul(pBuffer, 0, 10));
}

inline void deserialize(const char * pBuffer, int & rObject)
{
  rObject = static_cast<int>(strtol(pBuffer, 0, 10));
}

inline void deserialize(const char * pBuffer, unsigned int & rObject)
{
  rObject = static_cast<unsigned int>(strtoul(pBuffer, 0, 10));
}

inline void deserialize(const char * pBuffer, long & rObject)
{
  rObject = strtol(pBuffer, 0, 10);
}

inline void deserialize(const char * pBuffer, unsigned long & rObject)
{
  rObject = strtoul(pBuffer, 0, 10);
}

inline void deserialize(const char * pBuffer, float & rObject)
{
  rObject = static_cast<float>(atof(pBuffer));
}

inline void deserialize(const char * pBuffer, double & rObject)
{
  rObject = atof(pBuffer);
}

inline void deserialize(const char * pBuffer, SLongHex & rObject)
{
  rObject.mulHex = strtoul(pBuffer, 0, 16);
}



void deserialize(CReader & reader, std::string & rObject, const char * pszTag);

// deserialize types without a base or ordinal integers in decimal system
template <class _T>
void deserialize(CReader & reader, _T & object, const char * name)
{
  std::string text;
  int token = reader.getToken(text);

  // a simple element is either sth. serialized as string or a number
  if (token == CReader::STRING  ||  token == CReader::NUMBER)
  {
    deserialize(text.c_str(), object);
  }
  else
  {
    // TODO ERROR
    std::cerr << "parser error: value expected" << std::endl;
  }
}



template <class _K>
void deserialize(
  CReader & reader, std::set<_K> & object,
  const char * name, const char * nameItem)
{
  std::cerr << "parser info: set deserializer" << std::endl;

  std::string text;
  int token = reader.getToken(text);

  // token  must be an open square bracket
  if (token != CReader::SQUARE_BRACKET_LEFT)
  {
    // TODO ERROR
    std::cerr << "parser error: left square bracket expected" << std::endl;
  }

  do
  {
    _K _k;
    deserialize(reader, _k, 0);
    object.insert(_k);

    token = reader.getToken(text);
  }
  while (token == CReader::COMMA);

  if (token != CReader::SQUARE_BRACKET_RIGHT)
  {
    // TODO ERROR
    std::cerr << "parser error: right square bracket expected: " << tkn2str(token) << std::endl;
  }
}



template <class _T>
void deserialize(
  CReader & reader, std::list<_T> & object,
  const char * name, const char * nameItem)
{
  std::cerr << "parser info: list deserializer" << std::endl;

  std::string text;
  int token = reader.getToken(text);

  // token  must be an open square bracket
  if (token != CReader::SQUARE_BRACKET_LEFT)
  {
    // TODO ERROR
    std::cerr << "parser error: left square bracket expected" << std::endl;
  }

  do
  {
    _T _t;
    deserialize(reader, _t, 0);
    object.push_back(_t);

    token = reader.getToken(text);
  }
  while (token == CReader::COMMA);

  if (token != CReader::SQUARE_BRACKET_RIGHT)
  {
    // TODO ERROR
    std::cerr << "parser error: right square bracket expected: " << tkn2str(token) << std::endl;
  }
}



template <class _T>
void deserialize(
  CReader & reader, std::map<std::string, _T> & rObject,
  const char * pszTag, const char * pszTagItem, const char * pszTagId)
{
/*
  while (!reader.IsEof() && !reader.IsEndTag(pszTag))
  {
    if (reader.IsStartTag(pszTagItem, false))
    {
      std::string strKey;
      _T _t;
      deserialize(reader, _t, pszTagItem, pszTagId, &strKey);
#if 0 // this should suffice, but to be on the safe side we use the old method
      rObject[strKey] = _t;
#else
      typename std::map<std::string, _T>::iterator fnd = rObject.find(strKey);
      if (fnd != rObject.end())
      {
        rObject.erase(fnd);
      }
      rObject.insert(std::pair<std::string, _T>(strKey, _t));
#endif
      continue;
    }
    reader.SkipTag();
  } // while (!reader.IsEndTag(...))
*/
}



template <class _K, class _T>
void deserialize(
  CReader & reader, std::map<_K, _T> & rObject,
  const char * pszTag, const char * pszTagItem, const char * pszTagId)
{
/*
  while (!reader.IsEof() && !reader.IsEndTag(pszTag))
  {
    if (reader.IsStartTag(pszTagItem, false))
    {
      std::string strKey;
      _T _t;
      deserialize(reader, _t, pszTagItem, pszTagId, &strKey);
      _K _k;
      deserialize(strKey.c_str(), _k);
#if 0 // this should suffice, but to be on the safe side we use the old method
      rObject[_k] = _t;
#else
      typename std::map<_K, _T>::iterator fnd = rObject.find(_k);
      if (fnd != rObject.end())
      {
        rObject.erase(fnd);
      }
      rObject.insert(std::pair<_K, _T>(_k, _t));
#endif
      continue;
    }
    reader.SkipTag();
  } // while (!reader.IsEndTag(...))
*/
}



template <class _T>
void deserialize(
  CReader & reader, std::multimap<std::string, _T> & rObject,
  const char * pszTag, const char * pszTagItem, const char * pszTagId)
{
/*
  while (!reader.IsEof() && !reader.IsEndTag(pszTag))
  {
    if (reader.IsStartTag(pszTagItem, false))
    {
      std::string strKey;
      _T _t;
      deserialize(reader, _t, pszTagItem, pszTagId, &strKey);
      rObject.insert(std::pair<std::string, _T>(strKey, _t));
      continue;
    }
    reader.SkipTag();
  } // while (!reader.IsEndTag(...))
*/
}



template <class _K, class _T>
void deserialize(
  CReader & reader, std::multimap<_K, _T> & rObject,
  const char * pszTag, const char * pszTagItem, const char * pszTagId)
{
/*
  while (!reader.IsEof() && !reader.IsEndTag(pszTag))
  {
    if (reader.IsStartTag(pszTagItem, false))
    {
      std::string strKey;
      _T _t;
      deserialize(reader, _t, pszTagItem, pszTagId, &strKey);
      _K _k;
      deserialize(strKey.c_str(), _k);
      rObject.insert(std::pair<_K, _T>(_k, _t));
      continue;
    }
    reader.SkipTag();
  } // while (!reader.IsEndTag(...))
*/
}


#endif // _$(basename)Des_h_
********** [END]






********** [DI] PROLOG
// ------------------------------------------------------------------
// This is the structure deserializer implementation file.
// ------------------------------------------------------------------

#include "$(basename)Com.h"
#include "$(basename)Des.h"
//#include <stdlib.h>
********** [END]


********** [DI] FILE PROLOG
********** [END]


********** [DI] STRUCT PROLOG



void deserialize(CReader & reader, $(name) & rObject, const char * name,
  const char * idTag, std::string * idValue)
{
  std::string text;
  int token = reader.getToken(text);

  // token  must be open curly bracket
  if (token != CReader::CURLY_BRACKET_LEFT)
  {
    // TODO ERROR
    std::cerr << "parser error: left curly bracket expected" << std::endl;
  }

  // read first element
  token = reader.getToken(text);

  // if this is a container, the first element shall be the key
  if (idTag && idValue && token == CReader::STRING && text == idTag)
  {
    // read colon
    token = reader.getToken(text);
    // deserialize value
    deserialize(reader, *idValue, idTag);
    // read next token
    token = reader.getToken(text);
  }

  do
  {
********** [END]


********** [DI] GENERIC DECL

    if (token == CReader::STRING && text == "$(alias)")
    {
      // read colon
      token = reader.getToken(text);
      if (token != CReader::COLON)
      {
        // TODO ERROR
        std::cerr << "parser error: colon expected" << std::endl;
      }

      deserialize(reader, rObject.$(name), "$(alias)");

      token = reader.getToken(text);
      if (token == CReader::COMMA)
      {
        // prepare for next element
        token = reader.getToken(text);
      }
      else
      {
        // finished inside this struct
        break;
      }
    }
********** [END]


********** [DI] VECTOR DECL
/* TODO
    if (reader.IsStartTag("%s", false))\n", mstrAlias.c_str());
    {
      deserialize(reader, rObject.%s, "%s");\n", mstrName.c_str(), mstrAlias.c_str());
      continue;
    }
*/
********** [END]


********** [DI] SET/LIST DECL

    if (token == CReader::STRING && text == "$(alias)")
    {
      // read colon
      token = reader.getToken(text);
      if (token != CReader::COLON)
      {
        // TODO ERROR
        std::cerr << "parser error: colon expected" << std::endl;
      }

      deserialize(reader, rObject.$(name), "$(alias)", "$(item)");

      token = reader.getToken(text);
      if (token == CReader::COMMA)
      {
        // prepare for next element
        token = reader.getToken(text);
      }
      else
      {
        // finished inside this struct
        break;
      }
    }
********** [END]


********** [DI] MAP DECL
/*
    if (reader.IsStartTag("$(alias)", false))
    {
      deserialize(reader, rObject.$(name), "$(alias)", "$(item)", "$(id)");
      continue;
    }
*/
********** [END]


********** [DI] STRUCT EPILOG
  } while (false); // don't loop, just pass once

  if (token != CReader::CURLY_BRACKET_RIGHT)
  {
    // TODO ERROR
    std::cerr << "parser error: right curly bracket expected" << std::endl;
  }
}
********** [END]


********** [DI] FILE EPILOG
********** [END]


********** [DI] EPILOG



void deserialize(CReader & reader, std::string & object, const char * name)
{
  int token = reader.getToken(object);

  if (token != CReader::STRING)
  {
    // TODO ERROR
    std::cerr << "parser error: string value expected" << std::endl;
  }
}
********** [END]
